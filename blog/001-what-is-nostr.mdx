---
title: 什么是 Nostr?
date: 2025-12-12
authors:
  - name: CT
    pubkey: 24462930821b45f530ec0063eca0a6522e5a577856f982fa944df0ef3caf03ab
description: Nostr (Notes and Other Stuff Transmitted by Relays) 是一个去中心化的社交网络协议
tags:
  - 入门
---

Nostr（Notes and Other Stuff Transmitted by Relays）是一个去中心化的社交网络协议。

## 基本概念

### 事件（Events）

Nostr 中所有的数据都是以“事件”的形式存在的，每一条帖子、每一个点赞、你的个人资料、关注列表，都是一个事件。每个事件都经过用户的私钥签名，能确定事件的所有者。

### 公钥/私钥 (Public/Private Keys)

Nostr 与传统的社交网络不同，你不需要注册账号。你只需要一对随机生成的公钥和私钥。

- **公钥 (Public Key)**：类似于你的用户名，其他人通过它来识别你。在客户端中，它通常以 `npub1` 开头的格式显示。
- **私钥 (Private Key)**：类似于你的密码，它用来签署你的事件，向他人证明这些事件是你创建的。 **不要泄露你的私钥！** 私钥一旦泄露，别人就可以冒充你。密钥通常以 `nsec1` 开头的格式显示。

### 中继 (Relays)

中继为 Nostr 网络提供事件存储和查询服务。它们类似于传统社交网络的服务器，但任何人都可以运行一个中继。用户可以自主选择连接哪些中继，从而实现去中心化和抗审查。

NostrZH 社区提供了一个邀请制的中继，旨在为中文用户提供互相连接的空间。你可以通过联系社区成员获取邀请。在[此处](https://relay.nostrzh.org/)查看社区成员列表

社区中继地址：`wss://relay.nostrzh.org/`

### 客户端 (Clients)

客户端是用户与 Nostr 网络交互的应用程序。它们负责生成事件、签署事件、发送事件到中继，以及从中继获取事件并展示给用户。由于事件是存储在中继上的，所以用户可以随时更换自己喜欢的客户端。它更像是一个事件浏览器。

[探索 Nostr 客户端](https://nostrapps.com/)

## 如何实现抗审查？

一个事件一旦被签署过，那么它就是客观存在的，没有人能抹掉它窜改它（包括你自己）。它不需要由其他人来证明它的真实性，它自己可以通过密码学来证明自己是真实存在的。

你只需要将它发送到中继上让大家能够获取到它，你的声音就能被听到。

由于任何人都可以运行一个中继，所以不存在某个中继将你封禁导致你无法发声的问题，你可以随时更换中继，或者自己运行一个中继。所以 Nostr 是抗审查的。

> 既然事件被签署后是客观存在的，那是否可以通过其他方式传播事件呢？
> 
> 答案是肯定的。你可以通过任何方式（例如电子邮件、IM 软件、手抄到信纸上邮寄等）将事件内容传播给其他人，其他人只需要按照协议对签名进行验证，就能确认事件的真实性。

## 如何实现去中心化？

Nostr 协议本身并不依赖于任何中心化的服务器，任何人都可以运行一个中继，并且用户可以自主选择连接哪些中继，从而实现了去中心化。这样真的就实现去中心化了吗？

### Nostr 1.0 时代

没错，用户确实可以自主选择使用哪些中继，网络中也确实有许多不同的中继在运行着。在 Nostr 1.0 时代，客户端只会连接用户设置好的几个中继，并使用这些中继来获取事件和发送事件。

如果你和某个用户一个相同的中继都没有，那么你们就看不到彼此的事件。为了让更多人看到自己事件或者看到更多人的事件，用户往往会选择连接一些大型的公共中继，这导致了网络的中心化趋势。按这个趋势发展下去，Nostr 网络最终会变成几个大型公共中继主导的中心化网络。

### Nostr 2.0 时代

为了解决上一节提到的问题，Gossip 的开发者 [Mike Dilger](https://jumble.social/users/npub1acg6thl5psv62405rljzkj8spesceyfz2c32udakc2ak0dmvfeyse9p35c) 提出了 [Outbox Model](https://mikedilger.com/gossip-model/)，后来社区开发者还补充了 Inbox Model，合起来被称为 Mailbox Model。Ummm 总之现在叫什么的都有，大家知道是一个东西就好了，本文暂且称之为邮箱模型吧。

邮箱模型的核心思想是用户公开自己的中继列表，当需要获取某个事件时客户端应该根据该事件的作者公开的中继列表中寻找合适的中继进行获取。而不是仅仅依赖用户自己设置的中继列表。

用户的中继列表中主要需要设置两种中继：

- **写中继 (Outbox Relays)**：用来发送你自己的事件，理论上客户端应该把所有你签署的事件都发送到这些中继上。
- **读中继 (Inbox Relays)**：用来查询提及你的事件，例如别人点赞、评论、转发了你的帖子，可以简单理解为「收件箱」。当别人希望你看到时，他们的客户端应该把事件发送到你的读中继上。

我来用几个例子让大家感受一下邮箱模型是如何运作的：

1. 当你想查看小明的帖子时，你的客户端会先去几个大中继查询小明使用什么写中继，然后从小明的写中继上获取他的帖子。
2. 当你给小明的帖子点赞是，你的客户端首先会将点赞事件发送到你自己的写中继上，然后再发送到小明的读中继上，这样小明就能在他的收件箱中看到你的点赞事件。
3. 当你要查看通知时，你的客户端会去你的读中继上获取提及你的事件。

聪明的你一定想到了，如果要浏览所有关注用户的帖子，那岂不是要去每个关注用户的写中继上获取帖子？没错，邮箱模型确实会带来这样的开销。当你关注一两百人的时候，可能需要连接几十个中继（因为用户可能会使用相同的中继）。

这确实会带来一些性能上的问题，但也不是不能接受。但是如果你关注上千人的话，那确实会有很大的困扰。不过关注上千人本身是否有意义也是一个问题。

## 社群中继 (Community Relays)

这类中继的目的不是简单的为用户存储和分发事件，有运营者或算法对内容进行筛选，聚集一群有共性的用户或聚合某一类内容。有点类似于传统社交网络中的兴趣小组或者话题社区。

用户可以选择订阅这些社群中继，从而发现更多有趣的内容和用户。`wss://relay.nostrzh.org/` 就是一个让中文用户互相连接的社群中继。